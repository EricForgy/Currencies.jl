{
    "docs": [
        {
            "location": "/", 
            "text": "Currencies.jl\n\n\nThis package provides a simple interface to using a wide variety of currencies with checked arithmetic in Julia. While floating point arithmetic is very convenient for currency computations, there are common problems with using floating point comparisons. This package addresses those issues by treating monetary amounts as fixed-point decimals.\n\n\n\n\nContents\n\n\n\n\nInstallation \n Usage\n\n\nCreating \nMonetary\n Values\n\n\nCaution with \none\n\n\n\n\n\n\nValuation\n\n\nUsing the Internet\n\n\nSimilar Type Conversions\n\n\n\n\n\n\nDisplay \n Formatting\n\n\nQuick Display\n\n\nFormatting\n\n\n\n\n\n\nCustom Currencies\n\n\nRounding\n\n\nCustom Precision\n\n\nSpecial Metals\n\n\n\n\n\n\nNotes on Performance\n\n\nReference\n\n\n\n\n\n\nIndex\n\n\n\n\nCurrencies.AbstractMonetary\n\n\nCurrencies.Basket\n\n\nCurrencies.ExchangeRateTable\n\n\nCurrencies.FormatSpecification\n\n\nCurrencies.Monetary\n\n\nCurrencies.compile\n\n\nCurrencies.compoundfv\n\n\nCurrencies.currency\n\n\nCurrencies.currencyinfo\n\n\nCurrencies.decimals\n\n\nCurrencies.ecbrates\n\n\nCurrencies.filltype\n\n\nCurrencies.format\n\n\nCurrencies.iso4217alpha\n\n\nCurrencies.iso4217num\n\n\nCurrencies.longsymbol\n\n\nCurrencies.newcurrency!\n\n\nCurrencies.shortsymbol\n\n\nCurrencies.simplefv\n\n\nCurrencies.unit\n\n\nCurrencies.valuate\n\n\nCurrencies.@usingcurrencies\n\n\nCurrencies.@usingcustomcurrency", 
            "title": "Home"
        }, 
        {
            "location": "/#currenciesjl", 
            "text": "This package provides a simple interface to using a wide variety of currencies with checked arithmetic in Julia. While floating point arithmetic is very convenient for currency computations, there are common problems with using floating point comparisons. This package addresses those issues by treating monetary amounts as fixed-point decimals.", 
            "title": "Currencies.jl"
        }, 
        {
            "location": "/#contents", 
            "text": "Installation   Usage  Creating  Monetary  Values  Caution with  one    Valuation  Using the Internet  Similar Type Conversions    Display   Formatting  Quick Display  Formatting    Custom Currencies  Rounding  Custom Precision  Special Metals    Notes on Performance  Reference", 
            "title": "Contents"
        }, 
        {
            "location": "/#index", 
            "text": "Currencies.AbstractMonetary  Currencies.Basket  Currencies.ExchangeRateTable  Currencies.FormatSpecification  Currencies.Monetary  Currencies.compile  Currencies.compoundfv  Currencies.currency  Currencies.currencyinfo  Currencies.decimals  Currencies.ecbrates  Currencies.filltype  Currencies.format  Currencies.iso4217alpha  Currencies.iso4217num  Currencies.longsymbol  Currencies.newcurrency!  Currencies.shortsymbol  Currencies.simplefv  Currencies.unit  Currencies.valuate  Currencies.@usingcurrencies  Currencies.@usingcustomcurrency", 
            "title": "Index"
        }, 
        {
            "location": "/install/", 
            "text": "Installation \n Usage\n\n\nIn Julia, execute:\n\n\nPkg\n.\nadd\n(\nCurrencies\n)\n\n\n\n\n\n\nThen in your project (or in the REPL), use the package with:\n\n\nusing\n \nCurrencies\n\n\n\n\n\n\nAt this point you can import the currency symbols that you will need. Using the ISO 4217 codes, write:\n\n\n@\nusingcurrencies\n \nUSD\n,\n \nEUR\n,\n \nGBP\n\n\n\n\n\n\nBasic usage of this package is quite simple. For example, for a simple sum of \nMonetary\n values, we can write:\n\n\nsubtotal\n \n=\n \n100\nUSD\n\n\ntax\n \n=\n \n10\nUSD\n\n\ntotal\n \n=\n \nsubtotal\n \n+\n \ntax\n\n\n\n\n\n\n110.00 USD\n\n\n\n\n\nThe usual arithmetic operators are available.\n\n\n\n\nCreating \nMonetary\n Values\n\n\nAlthough using \n@usingcurrencies\n is the best and most idiomatic method of creating \nMonetary\n values, there are several others, some more flexible than others:\n\n\njulia\n \nMonetary\n(:\nUSD\n)\n\n\n1.00\n \nUSD\n\n\n\njulia\n \nMonetary\n(:\nUSD\n;\n \nprecision\n=\n4\n)\n\n\n1.0000\n \nUSD\n\n\n\njulia\n \nMonetary\n(:\nUSD\n;\n \nstorage\n=\nBigInt\n)\n\n\n1.00\n \nUSD\n\n\n\njulia\n \nzero\n(\nMonetary\n{:\nUSD\n})\n\n\n0.00\n \nUSD\n\n\n\njulia\n \nMonetary\n(:\nUSD\n,\n \n0\n)\n\n\n0.00\n \nUSD\n\n\n\njulia\n \nMonetary\n(:\nUSD\n,\n \n314\n)\n\n\n3.14\n \nUSD\n\n\n\njulia\n \nMonetary\n{:\nUSD\n,\n \nInt\n,\n \n4\n}(\n10000\n)\n\n\n1.0000\n \nUSD\n\n\n\n\n\n\nNote in particular that last two! The second argument to \nMonetary\n, if provided, should be an integer value, and similarly the argument to the inner constructor is also expected to be an integer. These constructors can be difficult to understand and should be avoided where possible.\n\n\n\n\nWarning\n\n\nCustom precisions and storage representations work fine if they're     consistently used. But if they're ever used in conjunction alongside the     default versions of the same currency, undesirable behavior may result.     Stick to the defaults if you do not need more precision.\n\n\n\n\n\n\nCaution with \none\n\n\nNote that the \none\n method returns the multiplicative identity. For currencies, this identity does not have a unit. That means that the type \none\n returns may be unintuitive:\n\n\njulia\n \none\n(\nMonetary\n{:\nUSD\n})\n\n\n1", 
            "title": "Installation & Usage"
        }, 
        {
            "location": "/install/#installation-usage", 
            "text": "In Julia, execute:  Pkg . add ( Currencies )   Then in your project (or in the REPL), use the package with:  using   Currencies   At this point you can import the currency symbols that you will need. Using the ISO 4217 codes, write:  @ usingcurrencies   USD ,   EUR ,   GBP   Basic usage of this package is quite simple. For example, for a simple sum of  Monetary  values, we can write:  subtotal   =   100 USD  tax   =   10 USD  total   =   subtotal   +   tax   110.00 USD  The usual arithmetic operators are available.", 
            "title": "Installation &amp; Usage"
        }, 
        {
            "location": "/install/#creating-monetary-values", 
            "text": "Although using  @usingcurrencies  is the best and most idiomatic method of creating  Monetary  values, there are several others, some more flexible than others:  julia   Monetary (: USD )  1.00   USD  julia   Monetary (: USD ;   precision = 4 )  1.0000   USD  julia   Monetary (: USD ;   storage = BigInt )  1.00   USD  julia   zero ( Monetary {: USD })  0.00   USD  julia   Monetary (: USD ,   0 )  0.00   USD  julia   Monetary (: USD ,   314 )  3.14   USD  julia   Monetary {: USD ,   Int ,   4 }( 10000 )  1.0000   USD   Note in particular that last two! The second argument to  Monetary , if provided, should be an integer value, and similarly the argument to the inner constructor is also expected to be an integer. These constructors can be difficult to understand and should be avoided where possible.   Warning  Custom precisions and storage representations work fine if they're     consistently used. But if they're ever used in conjunction alongside the     default versions of the same currency, undesirable behavior may result.     Stick to the defaults if you do not need more precision.", 
            "title": "Creating Monetary Values"
        }, 
        {
            "location": "/install/#caution-with-one", 
            "text": "Note that the  one  method returns the multiplicative identity. For currencies, this identity does not have a unit. That means that the type  one  returns may be unintuitive:  julia   one ( Monetary {: USD })  1", 
            "title": "Caution with one"
        }, 
        {
            "location": "/valuation/", 
            "text": "Valuation\n\n\nOne important operation on monetary amounts is the ability to valuate them. Both baskets and single \nMonetary\n objects can be \"converted\" (in some sense) to a reference currency using the \nvaluate\n function. This function takes some table mapping currency symbols to a simple floating point, which represents its value to some particular reference. It uses the table to compute the ratio between any two currencies that are both in the table, and then reduces each currency present in the basket into the desired basis currency. An example would explain it better than any words:\n\n\njulia\n \n@\nusingcurrencies\n \nUSD\n,\n \nJPY\n,\n \nEUR\n;\n\n\n\njulia\n \nusdmoney\n \n=\n \n100\nUSD\n;\n\n\n\njulia\n \nmybasket\n \n=\n \nBasket\n([\n100\nUSD\n,\n \n100\nJPY\n,\n \n100\nEUR\n]);\n\n\n\njulia\n \nrates\n \n=\n \nExchangeRateTable\n(\n\n               \n:\nUSD\n \n=\n \n1.0\n,\n\n               \n:\nJPY\n \n=\n \n0.02\n,\n\n               \n:\nEUR\n \n=\n \n1.2\n);\n\n\n\njulia\n \nvaluate\n(\nrates\n,\n \n:\nEUR\n,\n \nusdmoney\n)\n\n\n83.33\n \nEUR\n\n\n\njulia\n \nvaluate\n(\nrates\n,\n \n:\nJPY\n,\n \nmybasket\n)\n\n\n11100\n \nJPY\n\n\n\n\n\n\nThe \nExchangeRateTable\n type is a provided type that acts very similarly to a dictionary. In fact, passing a plain dictionary to \nvaluate\n would work too.\n\n\n\n\nUsing the Internet\n\n\nOften, it isn't practical to provide the data into the program itself. In these cases, it is helpful to download reputable data from the Internet. If an Internet connection is available, this package provides the \necbrates\n function, which gets some recent exchange rate data provided by the European Central Bank, using the \nfixer.io\n API:\n\n\n@\nusingcurrencies\n \nUSD\n,\n \nJPY\n\n\nusdmoney\n \n=\n \n100\nUSD\n\n\nvaluate\n(\necbrates\n(),\n \n:\nEUR\n,\n \nusdmoney\n)\n  \n# 12299 JPY (results may vary)\n\n\n\n\n\n\nThis data is not live and may be delayed several days, but for most currencies and for most uses it is acceptably recent. The available precision is around five decimal digits, which is more than enough for most applications.\n\n\nIf rates at some point in the past are desired, the \necbrates\n function accepts an optional parameter with the date:\n\n\njulia\n \nvaluate\n(\necbrates\n(\nDate\n(\n2015\n,\n \n08\n,\n \n05\n)),\n \n:\nEUR\n,\n \n100\nUSD\n)\n\n\n91.89\n \nEUR\n\n\n\n\n\n\n\n\nSimilar Type Conversions\n\n\nFor type safety reasons, \nMonetary\n objects of the same currency may be incompatible if stored with different precision or with a different internal representation. \nvaluate\n provides an explicit, if cumbersome, way to convert between these incompatible types:\n\n\njulia\n \nvaluate\n(\nDict\n(:\nUSD\n \n=\n \n1.0\n),\n \nMonetary\n{:\nUSD\n,\n \nBigInt\n,\n \n4\n},\n \n100\nUSD\n)\n\n\nERROR\n:\n \nUndefVarError\n:\n \nvaluate\n \nnot\n \ndefined\n\n\n\n\n\n\nType conversions and exchange rate valuations can be done at the same time too::\n\n\njulia\n \nmycash\n \n=\n \n200\nMonetary\n(:\nEUR\n;\n \nstorage\n=\nBigInt\n,\n \nprecision\n=\n4\n)\n\n\n200.0000\n \nEUR\n\n\n\njulia\n \nvaluate\n(\necbrates\n(),\n \nMonetary\n{:\nUSD\n,\n \nInt\n,\n \n4\n},\n \nmycash\n)\n\n\n218.8600\n \nUSD", 
            "title": "Valuation"
        }, 
        {
            "location": "/valuation/#valuation", 
            "text": "One important operation on monetary amounts is the ability to valuate them. Both baskets and single  Monetary  objects can be \"converted\" (in some sense) to a reference currency using the  valuate  function. This function takes some table mapping currency symbols to a simple floating point, which represents its value to some particular reference. It uses the table to compute the ratio between any two currencies that are both in the table, and then reduces each currency present in the basket into the desired basis currency. An example would explain it better than any words:  julia   @ usingcurrencies   USD ,   JPY ,   EUR ;  julia   usdmoney   =   100 USD ;  julia   mybasket   =   Basket ([ 100 USD ,   100 JPY ,   100 EUR ]);  julia   rates   =   ExchangeRateTable ( \n                : USD   =   1.0 , \n                : JPY   =   0.02 , \n                : EUR   =   1.2 );  julia   valuate ( rates ,   : EUR ,   usdmoney )  83.33   EUR  julia   valuate ( rates ,   : JPY ,   mybasket )  11100   JPY   The  ExchangeRateTable  type is a provided type that acts very similarly to a dictionary. In fact, passing a plain dictionary to  valuate  would work too.", 
            "title": "Valuation"
        }, 
        {
            "location": "/valuation/#using-the-internet", 
            "text": "Often, it isn't practical to provide the data into the program itself. In these cases, it is helpful to download reputable data from the Internet. If an Internet connection is available, this package provides the  ecbrates  function, which gets some recent exchange rate data provided by the European Central Bank, using the  fixer.io  API:  @ usingcurrencies   USD ,   JPY  usdmoney   =   100 USD  valuate ( ecbrates (),   : EUR ,   usdmoney )    # 12299 JPY (results may vary)   This data is not live and may be delayed several days, but for most currencies and for most uses it is acceptably recent. The available precision is around five decimal digits, which is more than enough for most applications.  If rates at some point in the past are desired, the  ecbrates  function accepts an optional parameter with the date:  julia   valuate ( ecbrates ( Date ( 2015 ,   08 ,   05 )),   : EUR ,   100 USD )  91.89   EUR", 
            "title": "Using the Internet"
        }, 
        {
            "location": "/valuation/#similar-type-conversions", 
            "text": "For type safety reasons,  Monetary  objects of the same currency may be incompatible if stored with different precision or with a different internal representation.  valuate  provides an explicit, if cumbersome, way to convert between these incompatible types:  julia   valuate ( Dict (: USD   =   1.0 ),   Monetary {: USD ,   BigInt ,   4 },   100 USD )  ERROR :   UndefVarError :   valuate   not   defined   Type conversions and exchange rate valuations can be done at the same time too::  julia   mycash   =   200 Monetary (: EUR ;   storage = BigInt ,   precision = 4 )  200.0000   EUR  julia   valuate ( ecbrates (),   Monetary {: USD ,   Int ,   4 },   mycash )  218.8600   USD", 
            "title": "Similar Type Conversions"
        }, 
        {
            "location": "/display/", 
            "text": "Display \n Formatting\n\n\n\n\nQuick Display\n\n\nThe representation used by \nshow\n and \nprint\n is the same, and is fairly compact. (Note that this behaviour is retained for compatibility and will likely change in the future.)\n\n\njulia\n \nshow\n(\n100\nUSD\n)\n\n\n100.0\n\n\n\n\n\n\nWhen a richer representation than \ntext/plain\n is available, such as in an IJulia environment, \nBasket\n and \nMonetary\n objects can render as LaTeX and Markdown, respectively:\n\n\njulia\n \nshow\n(\nSTDOUT\n,\n \ntext/latex\n,\n \n100\nUSD\n)\n\n\n\njulia\n \nshow\n(\nSTDOUT\n,\n \ntext/markdown\n,\n \nBasket\n([\n100\nUSD\n,\n \n100\nEUR\n]))\n\n\nERROR\n:\n \nUndefVarError\n:\n \nEUR\n \nnot\n \ndefined\n\n\n\n\n\n\n\n\nFormatting\n\n\nThis package provides powerful formatting for \nMonetary\n values, but at the present time not all of this functionality is exposed to the user. However, a convenient interface is provided to use some of that functionality: the \nformat\n function. By default, it formats currency in a way acceptable to people who work with finance:\n\n\njulia\n \nformat\n(\n100\nUSD\n)\n\n\n100.00 USD\n\n\n\njulia\n \nformat\n(\n-\n100\nUSD\n)\n\n\n(100.00) USD\n\n\n\n\n\n\nExtra information about the style desired can be provided in the :obj:\nstyles\n keyword argument:\n\n\njulia\n \nformat\n(\n1270\nUSD\n;\n \nstyles\n=\n[:\nus\n,\n \n:\nbrief\n])\n\n\n\\$1,270.00\n\n\n\njulia\n \nformat\n(\n-\n700\nEUR\n;\n \nstyles\n=\n[:\neuropean\n,\n \n:\nfinance\n])\n\n\nERROR\n:\n \nUndefVarError\n:\n \nEUR\n \nnot\n \ndefined\n\n\n\n\n\n\nCurrently, the available general styles are \n:finance\n and \n:brief\n. The \nfinance\n style formats negative numbers in a way familiar to accountants. The \nbrief\n style enforces shorter symbols and reduced spacing.\n\n\nThe available local styles are \n:us\n, \n:european\n, \nindian\n, \n:local\n. The \nlocal\n style attempts to use the convention in the majority of areas where the particular currency is used. Local styles almost certainly conflict, and at most one of these can be used at once.\n\n\nA \n:latex\n style is provided to make formatting work nicely in LaTeX math mode, and a \n:plain\n style (which has no requirements) is also provided for consistency.", 
            "title": "Display & Formatting"
        }, 
        {
            "location": "/display/#display-formatting", 
            "text": "", 
            "title": "Display &amp; Formatting"
        }, 
        {
            "location": "/display/#quick-display", 
            "text": "The representation used by  show  and  print  is the same, and is fairly compact. (Note that this behaviour is retained for compatibility and will likely change in the future.)  julia   show ( 100 USD )  100.0   When a richer representation than  text/plain  is available, such as in an IJulia environment,  Basket  and  Monetary  objects can render as LaTeX and Markdown, respectively:  julia   show ( STDOUT ,   text/latex ,   100 USD )  julia   show ( STDOUT ,   text/markdown ,   Basket ([ 100 USD ,   100 EUR ]))  ERROR :   UndefVarError :   EUR   not   defined", 
            "title": "Quick Display"
        }, 
        {
            "location": "/display/#formatting", 
            "text": "This package provides powerful formatting for  Monetary  values, but at the present time not all of this functionality is exposed to the user. However, a convenient interface is provided to use some of that functionality: the  format  function. By default, it formats currency in a way acceptable to people who work with finance:  julia   format ( 100 USD )  100.00 USD  julia   format ( - 100 USD )  (100.00) USD   Extra information about the style desired can be provided in the :obj: styles  keyword argument:  julia   format ( 1270 USD ;   styles = [: us ,   : brief ])  \\$1,270.00  julia   format ( - 700 EUR ;   styles = [: european ,   : finance ])  ERROR :   UndefVarError :   EUR   not   defined   Currently, the available general styles are  :finance  and  :brief . The  finance  style formats negative numbers in a way familiar to accountants. The  brief  style enforces shorter symbols and reduced spacing.  The available local styles are  :us ,  :european ,  indian ,  :local . The  local  style attempts to use the convention in the majority of areas where the particular currency is used. Local styles almost certainly conflict, and at most one of these can be used at once.  A  :latex  style is provided to make formatting work nicely in LaTeX math mode, and a  :plain  style (which has no requirements) is also provided for consistency.", 
            "title": "Formatting"
        }, 
        {
            "location": "/custom/", 
            "text": "Custom Currencies\n\n\nSometimes it is desirable to use a currency that lacks a ISO 4217 code, usually because it is not yet recognized by the ISO committee. These currencies are not supported by default. However, if your application requires them, there is a means to register new currencies.\n\n\nThis package exports \nnewcurrency!(symb, name, exponent) \nnewcurrency!\n, and a convenience macro \n@usingcustomcurrency\n. As convention, and to prevent name clashes with ISO 4217 currencies, all custom currencies should use lowercase letters (all default currencies use only uppercase letters). Note that the registration of a custom currency is global, so ensure that your application does not register the same currency as a package that your application depends on:\n\n\njulia\n \n@\nusingcustomcurrency\n \nxbt\n \nBitcoin\n \n8\n\n\n\njulia\n \n10\nxbt\n\n\n10.00000000\n \nxbt\n\n\n\njulia\n \npts\n \n=\n \nnewcurrency!\n(:\npts\n,\n \nPoints\n,\n \n0\n)\n\n\n1\n \npts\n\n\n\njulia\n \n10\npts\n\n\n10\n \npts\n\n\n\n\n\n\nSupposing that your application needs to handle any \nMonetary\n values, you may sometimes need to access the name or description of a currency, custom or not. This human-readable English-language description is exposed through the \ncurrencyinfo\n function, which takes either a currency symbol, a \nMonetary\n type, or a \nMonetary\n object:\n\n\njulia\n \ncurrencyinfo\n(:\nUSD\n)\n\n\nUS Dollar\n\n\n\n\n\n\nBe aware that custom currencies, in this form, are not intended for arbitrary creation of vast numbers of currencies on the fly. Due to global state, you must take care that the currencies you register do not interfere with default currencies or with some other package. A better and more robust system for custom currency creation may be possible by leveraging Julia's type system, but this will not be supported until a future version.", 
            "title": "Custom Currencies"
        }, 
        {
            "location": "/custom/#custom-currencies", 
            "text": "Sometimes it is desirable to use a currency that lacks a ISO 4217 code, usually because it is not yet recognized by the ISO committee. These currencies are not supported by default. However, if your application requires them, there is a means to register new currencies.  This package exports  newcurrency!(symb, name, exponent)  newcurrency! , and a convenience macro  @usingcustomcurrency . As convention, and to prevent name clashes with ISO 4217 currencies, all custom currencies should use lowercase letters (all default currencies use only uppercase letters). Note that the registration of a custom currency is global, so ensure that your application does not register the same currency as a package that your application depends on:  julia   @ usingcustomcurrency   xbt   Bitcoin   8  julia   10 xbt  10.00000000   xbt  julia   pts   =   newcurrency! (: pts ,   Points ,   0 )  1   pts  julia   10 pts  10   pts   Supposing that your application needs to handle any  Monetary  values, you may sometimes need to access the name or description of a currency, custom or not. This human-readable English-language description is exposed through the  currencyinfo  function, which takes either a currency symbol, a  Monetary  type, or a  Monetary  object:  julia   currencyinfo (: USD )  US Dollar   Be aware that custom currencies, in this form, are not intended for arbitrary creation of vast numbers of currencies on the fly. Due to global state, you must take care that the currencies you register do not interfere with default currencies or with some other package. A better and more robust system for custom currency creation may be possible by leveraging Julia's type system, but this will not be supported until a future version.", 
            "title": "Custom Currencies"
        }, 
        {
            "location": "/rounding/", 
            "text": "Rounding\n\n\nAlthough the goal of this package is to provide integer operations on monetary amounts, in practice, decimal operations are unavoidable. For instance, there is no good way to compute interest or commissions with just integer arithmetic. By default, this package enables multiplying and dividing \nBasket\n and \nMonetary\n objects with all numbers descending from \nReal\n, including floating points. In fact, the recommended way to construct \nMonetary\n objects is by implicit floating point multiplication. This isn't a problem unless the floating point numbers are so big that floating points lose precision::\n\n\n@\nusingcurrencies\n \nUSD\n\n\n90071992547409.91\nUSD\n  \n# 90071992547409.91 USD\n\n\n90071992547409.92\nUSD\n  \n# 90071992547409.92 USD\n\n\n90071992547409.93\nUSD\n  \n# 90071992547409.94 USD (!!)\n\n\n\n\n\n\nIf you intend to use numbers of that size, and you actually care about the very small relative error, then there are several solutions::\n\n\n@\nusingcurrencies\n \nUSD\n\n\nparse\n(\nBigFloat\n,\n \n90071992547409.93\n)\nUSD\n  \n# 90071992547409.93 USD\n\n\nMonetary\n(:\nUSD\n,\n \n9007199254740993\n)\n         \n# 90071992547409.93 USD\n\n\n\n\n\n\nMultiplication by arbitrary reals is useful, but there are some caveats. Firstly, be aware of rounding. By default, this package rounds to the nearest smallest denomination. Normally, this is not a problem. These rounding errors can pile up over time, however. Consider the following example:\n\n\n@\nusingcurrencies\n \nUSD\n\n\na\n \n=\n \n\u03c0\n \n*\n \nUSD\n    \n# 3.14 USD\n\n\nb\n \n=\n \n\u03c0\n \n*\n \na\n      \n# 9.86 USD\n\n\nc\n \n=\n \n\u03c0\n^\n2\n \n*\n \nUSD\n  \n# 9.87 USD (!!)\n\n\n\n\n\n\nThere is no single way to fix this problem, because depending on the situation that you want to model, the solution is different. One thing that helps in some circumstances is being able to specify the rounding method, or being able to do the calculations yourself. This package provides only the most useful rounding method, which is Julia's built-in \nround\n. To do a different rounding method, you must perform the calculations yourself, on a real type of your choice, by temporarily \"taking apart\" the data, and converting it back when it needs to be rounded (note that here, you're in charge of how to round the data). For example:\n\n\n@\nusingcurrencies\n \nUSD\n\n\nmoney\n \n=\n \n1\nUSD\n                   \n# 1 USD\n\n\nmagn\n \n=\n \nmoney\n.\nval\n               \n# 100\n\n\nsymb\n \n=\n \ncurrency\n(\nmoney\n)\n         \n# :USD\n\n\na\n \n=\n \n\u03c0\n \n*\n \nmagn\n                   \n# 314.159265...\n\n\nb\n \n=\n \n\u03c0\n \n*\n \na\n                      \n# 986.960440...\n\n\nMonetary\n(\nsymb\n,\n \nround\n(\nInt\n,\n \nb\n))\n  \n# 9.87 USD\n\n\n\n\n\n\n\n\nCustom Precision\n\n\nThe default precision for most currencies is down to the minor currency unit. For example, for the United States dollar, this minor currency unit is the cent. This is acceptable for most purposes, but in some situations more or less precision is necessary. The precision (the number of decimal points after the major currency unit) can be controlled as a third type parameter to \nMonetary\n:\n\n\njulia\n \nUSD_M\n \n=\n \nMonetary\n{:\nUSD\n,\n \nInt\n,\n \n3\n}(\n1000\n)\n\n\n1.000\n \nUSD\n\n\n\njulia\n \njulia\n \n10\nUSD_M\n \n+\n \n11.004\nUSD_M\n\n\nERROR\n:\n \nUndefVarError\n:\n \njulia\n \nnot\n \ndefined\n\n\n\n\n\n\nSometimes it is useful to override the second parameter too, to change the underlying storage precision:\n\n\njulia\n \nUSD_M\n \n=\n \nMonetary\n{:\nUSD\n,\n \nInt128\n,\n \n3\n}(\n1000\n)\n\n\n1.000\n \nUSD\n\n\n\njulia\n \n1267650600228229401496703205376\nUSD_M\n\n\n1267650600228229401496703205376.000\n \nUSD\n\n\n\n\n\n\nMixed arithmetic between precisions and representations is supported. However, it's important to note that mixed arithmetic may have significant performance implications. This is because for type safety, many combinations are converted unnecessarily to \nBigInt\n as an internal representation:\n\n\njulia\n \nUSD_M\n \n+\n \nUSD\n\n\nERROR\n:\n \nUndefVarError\n:\n \nUSD\n \nnot\n \ndefined\n\n\n\njulia\n \ndump\n(\nans\n)\n\n\nCurrencies\n.\nMonetary\n{:\nUSD\n,\nInt128\n,\n3\n}\n\n  \nval\n:\n \nInt128\n \n1267650600228229401496703205376000\n\n\n\n\n\n\nIn some situations, it may be better to implement these conversions manually.\n\n\n\n\nSpecial Metals\n\n\nSome \"currencies\", like XAU (gram of gold), have no sensible minor unit. For these currencies, the precision must be provided manually:\n\n\njulia\n \n@\nusingcurrencies\n \nXAU\n\n\nERROR\n:\n \nArgumentError\n:\n \nMust\n \nprovide\n \nprecision\n \nfor\n \ncurrency\n \nXAU\n.\n\n \nin\n \nMonetary\n \nat\n \n~/.\njulia\n/\nv0\n.\n5\n/\nCurrencies\n/\nsrc\n/\nmonetary\n.\njl\n:\n47\n\n \nin\n \neval\n \nat\n \n./\nboot\n.\njl\n:\n263\n\n\n\njulia\n \nconst\n \nXAU\n \n=\n \nMonetary\n(:\nXAU\n;\n \nprecision\n=\n4\n)\n\n \n1.0000\n \nXAU\n\n\n\n\n\n\nThe usual caveats apply\u2014be careful not to mix two different precisions of this currency. Otherwise, it can now be used like any other currency.", 
            "title": "Rounding"
        }, 
        {
            "location": "/rounding/#rounding", 
            "text": "Although the goal of this package is to provide integer operations on monetary amounts, in practice, decimal operations are unavoidable. For instance, there is no good way to compute interest or commissions with just integer arithmetic. By default, this package enables multiplying and dividing  Basket  and  Monetary  objects with all numbers descending from  Real , including floating points. In fact, the recommended way to construct  Monetary  objects is by implicit floating point multiplication. This isn't a problem unless the floating point numbers are so big that floating points lose precision::  @ usingcurrencies   USD  90071992547409.91 USD    # 90071992547409.91 USD  90071992547409.92 USD    # 90071992547409.92 USD  90071992547409.93 USD    # 90071992547409.94 USD (!!)   If you intend to use numbers of that size, and you actually care about the very small relative error, then there are several solutions::  @ usingcurrencies   USD  parse ( BigFloat ,   90071992547409.93 ) USD    # 90071992547409.93 USD  Monetary (: USD ,   9007199254740993 )           # 90071992547409.93 USD   Multiplication by arbitrary reals is useful, but there are some caveats. Firstly, be aware of rounding. By default, this package rounds to the nearest smallest denomination. Normally, this is not a problem. These rounding errors can pile up over time, however. Consider the following example:  @ usingcurrencies   USD  a   =   \u03c0   *   USD      # 3.14 USD  b   =   \u03c0   *   a        # 9.86 USD  c   =   \u03c0 ^ 2   *   USD    # 9.87 USD (!!)   There is no single way to fix this problem, because depending on the situation that you want to model, the solution is different. One thing that helps in some circumstances is being able to specify the rounding method, or being able to do the calculations yourself. This package provides only the most useful rounding method, which is Julia's built-in  round . To do a different rounding method, you must perform the calculations yourself, on a real type of your choice, by temporarily \"taking apart\" the data, and converting it back when it needs to be rounded (note that here, you're in charge of how to round the data). For example:  @ usingcurrencies   USD  money   =   1 USD                     # 1 USD  magn   =   money . val                 # 100  symb   =   currency ( money )           # :USD  a   =   \u03c0   *   magn                     # 314.159265...  b   =   \u03c0   *   a                        # 986.960440...  Monetary ( symb ,   round ( Int ,   b ))    # 9.87 USD", 
            "title": "Rounding"
        }, 
        {
            "location": "/rounding/#custom-precision", 
            "text": "The default precision for most currencies is down to the minor currency unit. For example, for the United States dollar, this minor currency unit is the cent. This is acceptable for most purposes, but in some situations more or less precision is necessary. The precision (the number of decimal points after the major currency unit) can be controlled as a third type parameter to  Monetary :  julia   USD_M   =   Monetary {: USD ,   Int ,   3 }( 1000 )  1.000   USD  julia   julia   10 USD_M   +   11.004 USD_M  ERROR :   UndefVarError :   julia   not   defined   Sometimes it is useful to override the second parameter too, to change the underlying storage precision:  julia   USD_M   =   Monetary {: USD ,   Int128 ,   3 }( 1000 )  1.000   USD  julia   1267650600228229401496703205376 USD_M  1267650600228229401496703205376.000   USD   Mixed arithmetic between precisions and representations is supported. However, it's important to note that mixed arithmetic may have significant performance implications. This is because for type safety, many combinations are converted unnecessarily to  BigInt  as an internal representation:  julia   USD_M   +   USD  ERROR :   UndefVarError :   USD   not   defined  julia   dump ( ans )  Currencies . Monetary {: USD , Int128 , 3 } \n   val :   Int128   1267650600228229401496703205376000   In some situations, it may be better to implement these conversions manually.", 
            "title": "Custom Precision"
        }, 
        {
            "location": "/rounding/#special-metals", 
            "text": "Some \"currencies\", like XAU (gram of gold), have no sensible minor unit. For these currencies, the precision must be provided manually:  julia   @ usingcurrencies   XAU  ERROR :   ArgumentError :   Must   provide   precision   for   currency   XAU . \n  in   Monetary   at   ~/. julia / v0 . 5 / Currencies / src / monetary . jl : 47 \n  in   eval   at   ./ boot . jl : 263  julia   const   XAU   =   Monetary (: XAU ;   precision = 4 ) \n  1.0000   XAU   The usual caveats apply\u2014be careful not to mix two different precisions of this currency. Otherwise, it can now be used like any other currency.", 
            "title": "Special Metals"
        }, 
        {
            "location": "/performance/", 
            "text": "Notes on Performance\n\n\nThis package abstracts the currency as part of the type, and not part of this value. This allows for increased performance, at some compile-time cost. For each currency, each arithmetic operation used on that currency incurs some small one-time cost.\n\n\nNote that the the only overhead for most arithmetic operations is just an indirection from the equivalent operation on integers:\n\n\njulia\n \ncode_native\n(\n+\n,\n \n(\ntypeof\n(\nUSD\n),\n \ntypeof\n(\nUSD\n)))\n\n  \n.\ntext\n\n\nFilename\n:\n \n~/.\njulia\n/\nv0\n.\n5\n/\nCurrencies\n/\nsrc\n/\nmonetary\n.\njl\n\n\nSource\n \nline\n:\n \n64\n\n    \npushq\n   \n%\nrbp\n\n    \nmovq\n    \n%\nrsp\n,\n \n%\nrbp\n\n\nSource\n \nline\n:\n \n64\n\n    \nmovq\n    \n(\n%\nrsi\n),\n \n%\nrax\n\n    \naddq\n    \n(\n%\nrdi\n),\n \n%\nrax\n\n    \npopq\n    \n%\nrbp\n\n    \nret\n\n\n\njulia\n \ncode_native\n(\n+\n,\n \n(\ntypeof\n(\n100\n),\n \ntypeof\n(\n100\n)))\n\n    \n.\ntext\n\n\nFilename\n:\n \nint\n.\njl\n\n\nSource\n \nline\n:\n \n8\n\n    \npushq\n   \n%\nrbp\n\n    \nmovq\n    \n%\nrsp\n,\n \n%\nrbp\n\n\nSource\n \nline\n:\n \n8\n\n    \naddq\n    \n%\nrsi\n,\n \n%\nrdi\n\n    \nmovq\n    \n%\nrdi\n,\n \n%\nrax\n\n    \npopq\n    \n%\nrbp\n\n    \nret", 
            "title": "Notes on Performance"
        }, 
        {
            "location": "/performance/#notes-on-performance", 
            "text": "This package abstracts the currency as part of the type, and not part of this value. This allows for increased performance, at some compile-time cost. For each currency, each arithmetic operation used on that currency incurs some small one-time cost.  Note that the the only overhead for most arithmetic operations is just an indirection from the equivalent operation on integers:  julia   code_native ( + ,   ( typeof ( USD ),   typeof ( USD ))) \n   . text  Filename :   ~/. julia / v0 . 5 / Currencies / src / monetary . jl  Source   line :   64 \n     pushq     % rbp \n     movq      % rsp ,   % rbp  Source   line :   64 \n     movq      ( % rsi ),   % rax \n     addq      ( % rdi ),   % rax \n     popq      % rbp \n     ret  julia   code_native ( + ,   ( typeof ( 100 ),   typeof ( 100 ))) \n     . text  Filename :   int . jl  Source   line :   8 \n     pushq     % rbp \n     movq      % rsp ,   % rbp  Source   line :   8 \n     addq      % rsi ,   % rdi \n     movq      % rdi ,   % rax \n     popq      % rbp \n     ret", 
            "title": "Notes on Performance"
        }, 
        {
            "location": "/reference/", 
            "text": "Reference\n\n\n#\n\n\nCurrencies.AbstractMonetary\n \n \nType\n.\n\n\nThe abstract type of objects representing a single value in one currency, or a collection of values in a set of currencies. These objects should behave like \nMonetary\n or \nBasket\n objects.\n\n\nsource\n\n\n#\n\n\nCurrencies.Basket\n \n \nType\n.\n\n\nA mutable collection of \nMonetary\n values of various currencies. Like regular \nMonetary\n values, \nBasket\n values support basic arithmetic operations, with both other baskets and with raw monetary values. The constructor for \nBasket\n accepts either a monetary value or a vector of monetary values.\n\n\nbasket = Basket([1USD, 5EUR])        # $1 + 5\u20ac\nbasket += 2EUR                       # $1 + 7\u20ac\nbasket *= 2                          # $2 + 14\u20ac\n\n\n\n\n\nBasket\n values also support iteration. The iteration order of currencies is undefined. For instance, the following will print \n1.00 USD\n and \n5.00 EUR\n, in some order. Iteration will skip over any currencies with zero weight in the basket.\n\n\nfor amt in Basket([1USD, 5EUR])\n    println(amt)\nend\n\n\n\n\n\nOne can also mutate the basket with index notation, or with \npush!\n.\n\n\nbasket = Basket([1USD, 2EUR])\nbasket[:USD] = 3USD  # Basket([3USD, 2EUR])\npush!(basket, 10GBP) # Basket([3USD, 2EUR, 10GBP])\n\n\n\n\n\nsource\n\n\n#\n\n\nCurrencies.ExchangeRateTable\n \n \nType\n.\n\n\nA table of exchange rates denominated in some currency. In which currency it is denominated is unimportant, so long as all exchange rates are denominated in the same currency. The denomination currency need not even exist in the table.\n\n\nOptionally, \nExchangeRateTable\n objects may contain information about the date for which they apply. If this isn't provided, then the current date is used.\n\n\nsource\n\n\n#\n\n\nCurrencies.FormatSpecification\n \n \nType\n.\n\n\nA collection of \nFormatRequirement\ns.\n\n\nsource\n\n\n#\n\n\nCurrencies.Monetary\n \n \nType\n.\n\n\nA representation of a monetary value, denominated in some currency. The currency used is part of the type and not the object. The value is internally represented as a quantity of some integer type. The usual way to construct a \nMonetary\n directly, if needed, is:\n\n\nMonetary(:USD)      # 1.00 USD\nMonetary(:USD, 325) # 3.25 USD\n\n\n\n\n\nBe careful about the decimal point, as the \nMonetary\n constructor takes an integer, representing the number of smallest denominations of the currency. Typically, this constructor is not called directly. It is easier to use the \n@usingcurrencies\n macro and the \n100USD\n form instead.\n\n\nAlthough this type is flexible enough to support values internally represented as any integer type, such as \nBigInt\n, it is recommended to use the built-in \nInt\n type on your architecture unless you need a bigger type. Do not mix different kinds of internal types. To use a different internal representation, change the type of the second argument to \nMonetary\n:\n\n\nMonetary(:USD, BigInt(100))\n\n\n\n\n\nIn some applications, the minor denomination of a currency is not precise enough. It is sometimes useful to override the number of decimal points stored. For these applications, a third type parameter can be provided, indicating the number of decimal points to keep after the major denomination:\n\n\nMonetary{:USD, BigInt, 4}(10000)            # 1.0000 USD\nMonetary(:USD, BigInt(10000); precision=4)  # 1.0000 USD\n\n\n\n\n\nsource\n\n\n#\n\n\nCurrencies.compile\n \n \nFunction\n.\n\n\nCompile the symbol requirement to a simplified form.\n\n\nIn the simplified form, the \nlocation\n field is guaranteed to take the value of \n:before\n or \n:after\n.\n\n\nsource\n\n\n#\n\n\nCurrencies.compoundfv\n \n \nFunction\n.\n\n\ncompoundfv(amount, interest, periods) \u2192 Monetary\n\n\n\n\n\nCompute the future value of the given monetary amount, at the given discount rate, compounded each period. For example, to find the future value of 1000 (US) today in 12 years, at an interest rate of 3% per year, compute:\n\n\ncompoundfv(1000USD, 0.03, 12)\n\n\n\n\n\nThis computation assumes exact compounding, and rounds only once at the end. If the compounding method in practice is rounded, then this result of this function will be incorrect.\n\n\nThis method is generic; any type for the PV is accepted provided that it is compatible with real multiplication. Negative values for the rate and the period are allowed.\n\n\nsource\n\n\n#\n\n\nCurrencies.currency\n \n \nFunction\n.\n\n\ncurrency(m::Monetary) \u2192 Symbol\n\n\n\n\n\nReturn a symbol corresponding to the ISO 4217 currency code of the currency that the given monetary amount is representing. For example, \ncurrency(80USD)\n will return \n:USD\n. If the given monetary value is of a non-ISO 4217 currency, then the returned symbol should contain only lowercase letters.\n\n\nPrefer \niso4217alpha\n to this function if a string is desired.\n\n\nsource\n\n\n#\n\n\nCurrencies.currencyinfo\n \n \nFunction\n.\n\n\nGet a brief human-readable English-language description of the currency. The description should begin with the common name of the currency, which should describe it unambiguously (up to variations on the same currency). Optionally, parentheses following the main description may include additional information (such as the unit of a major currency unit).\n\n\nThis function may be called with either a symbol, a \nMonetary\n type, or a \nMonetary\n object.\n\n\nsource\n\n\n#\n\n\nCurrencies.decimals\n \n \nFunction\n.\n\n\ndecimals(m::Monetary) \u2192 Int\ndecimals(s::Symbol)   \u2192 Int\ndecimals(d::DataType) \u2192 Int\n\n\n\n\n\nGet the precision, in terms of the number of decimal places after the major currency unit, of the given \nMonetary\n value or type. Alternatively, if given a symbol, gets the default exponent (the number of decimal places to represent the minor currency unit) for that symbol. Return \n-1\n if there is no sane minor unit, such as for several kinds of precious metal.\n\n\nsource\n\n\n#\n\n\nCurrencies.ecbrates\n \n \nFunction\n.\n\n\necbrates()           \u2192 ExchangeRateTable\necbrates(date::Date) \u2192 ExchangeRateTable\n\n\n\n\n\nGet an \nExchangeRateTable\n from European Central Bank data for the specified date, or for the most recent date available. European Central Bank data is not available for all currencies, and it is often out of date. This function requires a connection to the Internet, and reraises whatever exception is thrown from the \nRequests\n package if the connection fails for any reason.\n\n\nData is retrieved from https://fixer.io/, and then cached in memory to avoid excessive network traffic. Because of the nature of cached data, an application running for a long period of time may receive data that is one week or more out of date.\n\n\nsource\n\n\n#\n\n\nCurrencies.filltype\n \n \nFunction\n.\n\n\nfilltype(typ) \u2192 typ\n\n\n\n\n\nFill in default type parameters to get a fully-specified concrete type from a partially-specified one.\n\n\nsource\n\n\n#\n\n\nCurrencies.format\n \n \nFunction\n.\n\n\nformat\n(\nm\n:\n:Monetary\n;\n \nstyles\n=\n[\n:\nfinance\n]\n)\n\n\n\n\n\n\nFormat the given monetary amount to meet the requirements of the given style. Available styles are: \n:finance\n, \n:us\n, \n:european\n, and \n:brief\n. For LaTeX output, provide \n:latex\n. For plain output (default), provide \n:plain\n.\n\n\nsource\n\n\n#\n\n\nCurrencies.iso4217alpha\n \n \nFunction\n.\n\n\niso4217alpha(s::Symbol)   \u2192 String\niso4217alpha(m::Monetary) \u2192 String\niso4217alpha(t::DataType) \u2192 String\n\n\n\n\n\nGet the ISO 4217 alphabetic code for a currency. For custom currencies, a lowercase string will be returned, and this should not be interpreted as an ISO 4217 code. Otherwise, a three-letter uppercase string will be returned. This function may be called with either a symbol, a \nMonetary\n type, or a \nMonetary\n object.\n\n\nsource\n\n\n#\n\n\nCurrencies.iso4217num\n \n \nFunction\n.\n\n\niso4217num(s::Symbol)   \u2192 Int\niso4217num(m::Monetary) \u2192 Int\niso4217num(t::DataType) \u2192 Int\n\n\n\n\n\nGet the ISO 4217 numeric code for a currency. For custom currencies, a value of \n0\n will be returned. This function may be called with either a symbol, a \nMonetary\n type, or a \nMonetary\n object. Note that most applications should zero-pad this code to three digits.\n\n\nsource\n\n\n#\n\n\nCurrencies.longsymbol\n \n \nFunction\n.\n\n\nlongsymbol(s::Symbol)   \u2192 String\nlongsymbol(m::Monetary) \u2192 String\nlongsymbol(t::DataType) \u2192 String\n\n\n\n\n\nGet a commonly-used currency symbol for a currency, with at least enough disambiguation to be non-ambiguous. This function may be called with either a symbol, a \nMonetary\n type, or a \nMonetary\n object.\n\n\nsource\n\n\n#\n\n\nCurrencies.newcurrency!\n \n \nFunction\n.\n\n\nAdd a new currency to the (global) currency list and return a unit for that currency. Prefer the \n@usingcustomcurrency\n macro, which leads to more clear code, whenever possible. This function takes three arguments: the symbol for the currency, a string description of the currency (following the conventions outlined in the documentation for \ncurrencyinfo\n), and an exponent representing the number of decimal points to describe the minor currency unit in terms of the major currency unit. Conventionally, the symbol used to describe custom currencies should consist of only lowercase letters.\n\n\nbtc = newcurrency!(:btc, \nBitcoin\n, 8)  # 1.00000000 BTC\n\n\n\n\n\nsource\n\n\n#\n\n\nCurrencies.shortsymbol\n \n \nFunction\n.\n\n\nshortsymbol(s::Symbol)   \u2192 String\nshortsymbol(m::Monetary) \u2192 String\nshortsymbol(t::DataType) \u2192 String\n\n\n\n\n\nGet a short, possibly ambiguous, commonly-used symbol for a currency. This function may be called with either a symbol, a \nMonetary\n type, or a \nMonetary\n object.\n\n\nsource\n\n\n#\n\n\nCurrencies.simplefv\n \n \nFunction\n.\n\n\nsimplefv(amount, interest, periods) \u2192 Monetary\n\n\n\n\n\nCompute the future value of the given monetary amount, at the given discount rate, compounded each period on the principal only. This is known as \"simple interest\"; note that this is very rare in practice. For example, to find the future value of 1000 (US) today in 12 years, at a simple interest rate of 5% per year, compute:\n\n\nsimplefv(1000USD, 0.05, 12)\n\n\n\n\n\nThis computation rounds only once at the end. If the amounts in practice are rounded, then this result of this function will be incorrect.\n\n\nThis method is generic; any type for the PV is accepted provided that it is compatible with real multiplication. Negative values for the rate and the period are allowed.\n\n\nsource\n\n\n#\n\n\nCurrencies.unit\n \n \nFunction\n.\n\n\nlongsymbol(s::Symbol)   \u2192 Monetary{s} longsymbol(m::Monetary) \u2192 typeof(m) longsymbol(t::DataType) \u2192 t\n\n\nGet the major unit of the currency. This function may be called with either a symbol, a \nMonetary\n type, or a \nMonetary\n object.\n\n\nsource\n\n\n#\n\n\nCurrencies.valuate\n \n \nFunction\n.\n\n\nvaluate(table, as::Symbol, amount::Monetary)   \u2192 Monetary{as}\nvaluate(table, as::DataType, amount::Monetary) \u2192 as\n\n\n\n\n\nReduce the given \nMonetary\n or \nBasket\n to a value in a single specified currency or of a single specified type, using the given exchange rate table. The exchange rate table can either be an \nExchangeRateTable\n or any other \nAssociative\n mapping \nSymbol\n to \nReal\n.\n\n\nrates = ExchangeRateTable(:USD =\n 1.0, :CAD =\n 0.75)\nvaluate(rates, :CAD, 21USD)  # 28CAD\n\n\n\n\n\nsource\n\n\n#\n\n\nCurrencies.@usingcurrencies\n \n \nMacro\n.\n\n\nExport each given currency symbol into the current namespace. The individual unit exported will be a full unit of the currency specified, not the smallest possible unit. For instance, \n@usingcurrencies EUR\n will export \nEUR\n, a currency unit worth 1\u20ac, not a currency unit worth 0.01\u20ac.\n\n\n@usingcurrencies EUR, GBP, AUD\n7AUD  # 7.00 AUD\n\n\n\n\n\nThere is no sane unit for certain currencies like \nXAU\n or \nXAG\n, so this macro does not work for those. Instead, define them manually:\n\n\nconst XAU = Monetary(:XAU; precision=4)\n\n\n\n\n\nsource\n\n\n#\n\n\nCurrencies.@usingcustomcurrency\n \n \nMacro\n.\n\n\nAdd a new currency to the (global) currency list and assign a variable in the local namespace to that currency's unit. Provide three arguments: an identifier for the currency, a string description of the currency (following the conventions outlined in the documentation for \ncurrencyinfo\n), and an exponent representing the number of decimal points to describe the minor currency unit in terms of the major currency unit. Conventionally, the identifer used to describe custom currencies should consist of only lowercase letters.\n\n\n@usingcustomcurrency btc \nBitcoin\n 8\n10btc  # 10.00000000 btc\n\n\n\n\n\nsource", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#reference", 
            "text": "#  Currencies.AbstractMonetary     Type .  The abstract type of objects representing a single value in one currency, or a collection of values in a set of currencies. These objects should behave like  Monetary  or  Basket  objects.  source  #  Currencies.Basket     Type .  A mutable collection of  Monetary  values of various currencies. Like regular  Monetary  values,  Basket  values support basic arithmetic operations, with both other baskets and with raw monetary values. The constructor for  Basket  accepts either a monetary value or a vector of monetary values.  basket = Basket([1USD, 5EUR])        # $1 + 5\u20ac\nbasket += 2EUR                       # $1 + 7\u20ac\nbasket *= 2                          # $2 + 14\u20ac  Basket  values also support iteration. The iteration order of currencies is undefined. For instance, the following will print  1.00 USD  and  5.00 EUR , in some order. Iteration will skip over any currencies with zero weight in the basket.  for amt in Basket([1USD, 5EUR])\n    println(amt)\nend  One can also mutate the basket with index notation, or with  push! .  basket = Basket([1USD, 2EUR])\nbasket[:USD] = 3USD  # Basket([3USD, 2EUR])\npush!(basket, 10GBP) # Basket([3USD, 2EUR, 10GBP])  source  #  Currencies.ExchangeRateTable     Type .  A table of exchange rates denominated in some currency. In which currency it is denominated is unimportant, so long as all exchange rates are denominated in the same currency. The denomination currency need not even exist in the table.  Optionally,  ExchangeRateTable  objects may contain information about the date for which they apply. If this isn't provided, then the current date is used.  source  #  Currencies.FormatSpecification     Type .  A collection of  FormatRequirement s.  source  #  Currencies.Monetary     Type .  A representation of a monetary value, denominated in some currency. The currency used is part of the type and not the object. The value is internally represented as a quantity of some integer type. The usual way to construct a  Monetary  directly, if needed, is:  Monetary(:USD)      # 1.00 USD\nMonetary(:USD, 325) # 3.25 USD  Be careful about the decimal point, as the  Monetary  constructor takes an integer, representing the number of smallest denominations of the currency. Typically, this constructor is not called directly. It is easier to use the  @usingcurrencies  macro and the  100USD  form instead.  Although this type is flexible enough to support values internally represented as any integer type, such as  BigInt , it is recommended to use the built-in  Int  type on your architecture unless you need a bigger type. Do not mix different kinds of internal types. To use a different internal representation, change the type of the second argument to  Monetary :  Monetary(:USD, BigInt(100))  In some applications, the minor denomination of a currency is not precise enough. It is sometimes useful to override the number of decimal points stored. For these applications, a third type parameter can be provided, indicating the number of decimal points to keep after the major denomination:  Monetary{:USD, BigInt, 4}(10000)            # 1.0000 USD\nMonetary(:USD, BigInt(10000); precision=4)  # 1.0000 USD  source  #  Currencies.compile     Function .  Compile the symbol requirement to a simplified form.  In the simplified form, the  location  field is guaranteed to take the value of  :before  or  :after .  source  #  Currencies.compoundfv     Function .  compoundfv(amount, interest, periods) \u2192 Monetary  Compute the future value of the given monetary amount, at the given discount rate, compounded each period. For example, to find the future value of 1000 (US) today in 12 years, at an interest rate of 3% per year, compute:  compoundfv(1000USD, 0.03, 12)  This computation assumes exact compounding, and rounds only once at the end. If the compounding method in practice is rounded, then this result of this function will be incorrect.  This method is generic; any type for the PV is accepted provided that it is compatible with real multiplication. Negative values for the rate and the period are allowed.  source  #  Currencies.currency     Function .  currency(m::Monetary) \u2192 Symbol  Return a symbol corresponding to the ISO 4217 currency code of the currency that the given monetary amount is representing. For example,  currency(80USD)  will return  :USD . If the given monetary value is of a non-ISO 4217 currency, then the returned symbol should contain only lowercase letters.  Prefer  iso4217alpha  to this function if a string is desired.  source  #  Currencies.currencyinfo     Function .  Get a brief human-readable English-language description of the currency. The description should begin with the common name of the currency, which should describe it unambiguously (up to variations on the same currency). Optionally, parentheses following the main description may include additional information (such as the unit of a major currency unit).  This function may be called with either a symbol, a  Monetary  type, or a  Monetary  object.  source  #  Currencies.decimals     Function .  decimals(m::Monetary) \u2192 Int\ndecimals(s::Symbol)   \u2192 Int\ndecimals(d::DataType) \u2192 Int  Get the precision, in terms of the number of decimal places after the major currency unit, of the given  Monetary  value or type. Alternatively, if given a symbol, gets the default exponent (the number of decimal places to represent the minor currency unit) for that symbol. Return  -1  if there is no sane minor unit, such as for several kinds of precious metal.  source  #  Currencies.ecbrates     Function .  ecbrates()           \u2192 ExchangeRateTable\necbrates(date::Date) \u2192 ExchangeRateTable  Get an  ExchangeRateTable  from European Central Bank data for the specified date, or for the most recent date available. European Central Bank data is not available for all currencies, and it is often out of date. This function requires a connection to the Internet, and reraises whatever exception is thrown from the  Requests  package if the connection fails for any reason.  Data is retrieved from https://fixer.io/, and then cached in memory to avoid excessive network traffic. Because of the nature of cached data, an application running for a long period of time may receive data that is one week or more out of date.  source  #  Currencies.filltype     Function .  filltype(typ) \u2192 typ  Fill in default type parameters to get a fully-specified concrete type from a partially-specified one.  source  #  Currencies.format     Function .  format ( m : :Monetary ;   styles = [ : finance ] )   Format the given monetary amount to meet the requirements of the given style. Available styles are:  :finance ,  :us ,  :european , and  :brief . For LaTeX output, provide  :latex . For plain output (default), provide  :plain .  source  #  Currencies.iso4217alpha     Function .  iso4217alpha(s::Symbol)   \u2192 String\niso4217alpha(m::Monetary) \u2192 String\niso4217alpha(t::DataType) \u2192 String  Get the ISO 4217 alphabetic code for a currency. For custom currencies, a lowercase string will be returned, and this should not be interpreted as an ISO 4217 code. Otherwise, a three-letter uppercase string will be returned. This function may be called with either a symbol, a  Monetary  type, or a  Monetary  object.  source  #  Currencies.iso4217num     Function .  iso4217num(s::Symbol)   \u2192 Int\niso4217num(m::Monetary) \u2192 Int\niso4217num(t::DataType) \u2192 Int  Get the ISO 4217 numeric code for a currency. For custom currencies, a value of  0  will be returned. This function may be called with either a symbol, a  Monetary  type, or a  Monetary  object. Note that most applications should zero-pad this code to three digits.  source  #  Currencies.longsymbol     Function .  longsymbol(s::Symbol)   \u2192 String\nlongsymbol(m::Monetary) \u2192 String\nlongsymbol(t::DataType) \u2192 String  Get a commonly-used currency symbol for a currency, with at least enough disambiguation to be non-ambiguous. This function may be called with either a symbol, a  Monetary  type, or a  Monetary  object.  source  #  Currencies.newcurrency!     Function .  Add a new currency to the (global) currency list and return a unit for that currency. Prefer the  @usingcustomcurrency  macro, which leads to more clear code, whenever possible. This function takes three arguments: the symbol for the currency, a string description of the currency (following the conventions outlined in the documentation for  currencyinfo ), and an exponent representing the number of decimal points to describe the minor currency unit in terms of the major currency unit. Conventionally, the symbol used to describe custom currencies should consist of only lowercase letters.  btc = newcurrency!(:btc,  Bitcoin , 8)  # 1.00000000 BTC  source  #  Currencies.shortsymbol     Function .  shortsymbol(s::Symbol)   \u2192 String\nshortsymbol(m::Monetary) \u2192 String\nshortsymbol(t::DataType) \u2192 String  Get a short, possibly ambiguous, commonly-used symbol for a currency. This function may be called with either a symbol, a  Monetary  type, or a  Monetary  object.  source  #  Currencies.simplefv     Function .  simplefv(amount, interest, periods) \u2192 Monetary  Compute the future value of the given monetary amount, at the given discount rate, compounded each period on the principal only. This is known as \"simple interest\"; note that this is very rare in practice. For example, to find the future value of 1000 (US) today in 12 years, at a simple interest rate of 5% per year, compute:  simplefv(1000USD, 0.05, 12)  This computation rounds only once at the end. If the amounts in practice are rounded, then this result of this function will be incorrect.  This method is generic; any type for the PV is accepted provided that it is compatible with real multiplication. Negative values for the rate and the period are allowed.  source  #  Currencies.unit     Function .  longsymbol(s::Symbol)   \u2192 Monetary{s} longsymbol(m::Monetary) \u2192 typeof(m) longsymbol(t::DataType) \u2192 t  Get the major unit of the currency. This function may be called with either a symbol, a  Monetary  type, or a  Monetary  object.  source  #  Currencies.valuate     Function .  valuate(table, as::Symbol, amount::Monetary)   \u2192 Monetary{as}\nvaluate(table, as::DataType, amount::Monetary) \u2192 as  Reduce the given  Monetary  or  Basket  to a value in a single specified currency or of a single specified type, using the given exchange rate table. The exchange rate table can either be an  ExchangeRateTable  or any other  Associative  mapping  Symbol  to  Real .  rates = ExchangeRateTable(:USD =  1.0, :CAD =  0.75)\nvaluate(rates, :CAD, 21USD)  # 28CAD  source  #  Currencies.@usingcurrencies     Macro .  Export each given currency symbol into the current namespace. The individual unit exported will be a full unit of the currency specified, not the smallest possible unit. For instance,  @usingcurrencies EUR  will export  EUR , a currency unit worth 1\u20ac, not a currency unit worth 0.01\u20ac.  @usingcurrencies EUR, GBP, AUD\n7AUD  # 7.00 AUD  There is no sane unit for certain currencies like  XAU  or  XAG , so this macro does not work for those. Instead, define them manually:  const XAU = Monetary(:XAU; precision=4)  source  #  Currencies.@usingcustomcurrency     Macro .  Add a new currency to the (global) currency list and assign a variable in the local namespace to that currency's unit. Provide three arguments: an identifier for the currency, a string description of the currency (following the conventions outlined in the documentation for  currencyinfo ), and an exponent representing the number of decimal points to describe the minor currency unit in terms of the major currency unit. Conventionally, the identifer used to describe custom currencies should consist of only lowercase letters.  @usingcustomcurrency btc  Bitcoin  8\n10btc  # 10.00000000 btc  source", 
            "title": "Reference"
        }
    ]
}